{"componentChunkName":"component---src-templates-post-js","path":"/microtask-queue/","webpackCompilationHash":"fefbad52c3d6156b2190","result":{"data":{"markdownRemark":{"html":"<h1 id=\"microtasks\"><a href=\"#microtasks\" aria-label=\"microtasks permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Microtasks</h1>\n<p>Promise handlers <code class=\"language-text\">.then</code>/<code class=\"language-text\">.catch</code>/<code class=\"language-text\">.finally</code> are always asynchronous.</p>\n<p>Even when a Promise is immediately resolved, the code on the lines <em>below</em> <code class=\"language-text\">.then</code>/<code class=\"language-text\">.catch</code>/<code class=\"language-text\">.finally</code> will still execute before these handlers .</p>\n<p>Here's the demo:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> promise <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\npromise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"promise done!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"code finished\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// this alert shows first</span></code></pre></div>\n<p>If you run it, you see <code class=\"language-text\">code finished</code> first, and then <code class=\"language-text\">promise done!</code>.</p>\n<p>That's strange, because the promise is definitely done from the beginning.</p>\n<p>Why did the <code class=\"language-text\">.then</code> trigger afterwards? What's going on?</p>\n<h2 id=\"microtasks-queue\"><a href=\"#microtasks-queue\" aria-label=\"microtasks queue permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Microtasks queue</h2>\n<p>Asynchronous tasks need proper management. For that, the standard specifies an internal queue <code class=\"language-text\">PromiseJobs</code>, more often referred to as \"microtask queue\" (v8 term).</p>\n<p>As said in the <a href=\"https://tc39.github.io/ecma262/#sec-jobs-and-job-queues\">specification</a>:</p>\n<ul>\n<li>The queue is first-in-first-out: tasks enqueued first are run first.</li>\n<li>Execution of a task is initiated only when nothing else is running.</li>\n</ul>\n<p>Or, to say that simply, when a promise is ready, its <code class=\"language-text\">.then/catch/finally</code> handlers are put into the queue. They are not executed yet. JavaScript engine takes a task from the queue and executes it, when it becomes free from the current code.</p>\n<p>That's why \"code finished\" in the example above shows first.</p>\n<p><img src=\"/37dc8d4400a5078fbdea414c5654e0d6/promiseQueue.svg\"></p>\n<p>Promise handlers always go through that internal queue.</p>\n<p>If there's a chain with multiple <code class=\"language-text\">.then/catch/finally</code>, then every one of them is executed asynchronously. That is, it first gets queued, and executed when the current code is complete and previously queued handlers are finished.</p>\n<p><strong>What if the order matters for us? How can we make <code class=\"language-text\">code finished</code> work after <code class=\"language-text\">promise done</code>?</strong></p>\n<p>Easy, just put it into the queue with <code class=\"language-text\">.then</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"promise done!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"code finished\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Now the order is as intended.</p>\n<h2 id=\"unhandled-rejection\"><a href=\"#unhandled-rejection\" aria-label=\"unhandled rejection permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Unhandled rejection</h2>\n<p>Remember <code class=\"language-text\">unhandledrejection</code> event from the chapter &#x3C;info:promise-error-handling>?</p>\n<p>Now we can see exactly how JavaScript finds out that there was an unhandled rejection</p>\n<p><strong>\"Unhandled rejection\" occurs when a promise error is not handled at the end of the microtask queue.</strong></p>\n<p>Normally, if we expect an error, we add <code class=\"language-text\">.catch</code> to the promise chain to handle it:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> promise <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Promise Failed!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\npromise<span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'caught'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\">// doesn't run: error handled</span>\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'unhandledrejection'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">event</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>...But if we forget to add <code class=\"language-text\">.catch</code>, then, after the microtask queue is empty, the engine triggers the event:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> promise <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Promise Failed!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Promise Failed!</span>\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'unhandledrejection'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">event</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>What if we handle the error later? Like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> promise <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Promise Failed!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> promise<span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'caught'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\">// Error: Promise Failed!</span>\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'unhandledrejection'</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">event</span> <span class=\"token operator\">=></span> <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Now, if you run it, we'll see <code class=\"language-text\">Promise Failed!</code> message first, and then <code class=\"language-text\">caught</code>. </p>\n<p>If we didn't know about microtasks queue, we could wonder: \"Why did <code class=\"language-text\">unhandledrejection</code> handler run? We did catch the error!\".</p>\n<p>But now we understand that <code class=\"language-text\">unhandledrejection</code> is generated when the microtask queue is complete: the engine examines promises and, if any of them is in \"rejected\" state, then the event triggers.</p>\n<p>In the example above, <code class=\"language-text\">.catch</code> added by <code class=\"language-text\">setTimeout</code> also triggers, but later, after <code class=\"language-text\">unhandledrejection</code> has already occurred, so that doesn't change anything.</p>\n<h2 id=\"summary\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h2>\n<p>Promise handling is always asynchronous, as all promise actions pass through the internal \"promise jobs\" queue, also called \"microtask queue\" (v8 term).</p>\n<p>So, <code class=\"language-text\">.then/catch/finally</code> handlers are always called after the current code is finished.</p>\n<p>If we need to guarantee that a piece of code is executed after <code class=\"language-text\">.then/catch/finally</code>, we can add it into a chained <code class=\"language-text\">.then</code> call.</p>\n<p>In most Javascript engines, including browsers and Node.js, the concept of microtasks is closely tied with \"event loop\" and \"macrotasks\". As these have no direct relation to promises, they are covered in another part of the tutorial, in the chapter &#x3C;info:event-loop>.</p>","timeToRead":3,"excerpt":"Microtasks Promise handlers // are always asynchronous. Even when a Promise is immediately resolved, the code on the lines below // will…","frontmatter":{"title":"[javascript.info] - Asynchronous: Microtask Queue","thumbnail":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsSAAALEgHS3X78AAAB+0lEQVQ4y2P4eCeYbMTw4bYf2Qio2Z9sNAw1vwcjBPcWCJFj87ubwOD1/3QXpP/dTWJshlkFtP/X48B3t/xfXvX78Sjw24MAiDgDVj2f7/k/veibEm9RmG318Y7/l/sBi6c5BfqZurkal+RZXTvi/eUeSD92zUDVD8/6GhkbODkZ/3kauG2Fm7KarqOjUVSYmaSsTn257U+gQ27i0nwv4NE5XxtrQy9Pk/8vg9rr7KTldbascP3/IXjXardH532BnsfpbKDmh+d8La0MPd1N/j0PXDrDWU5JNyTIbMsy128PA349CYSEGQO2gEVo9vY0AbJfX/cDel5BRVdBWdff13T/BvfvDwOwOBsYpEAnfbob8OCMr5WVoY+XCSTAfjwG+tw1LdFCTUPP3Nzw6mFvYJgzoDn4x6OAx+d9gQ57dc3P0hJkM1ARMOQvHfD6/zb4/7vgtlqQ/5fNcv7zLJAB2bVAnctnO1taGi2a5rRkhrOKml5ijAXQIcBABob84hnOR7Z4JMWayyrobl3u9vsJqmagT3atcbOwMARKyynpGJsY7FjpBowqYIBZWBrKKgIFdRVVdAsyrd7e8AN6B93ZPx8H3Dnls2qeC9Bhlw56QRIT0BdAwfULXRbPcAKGFlDlZ6yJBGj/1/sBv58GAhEwViDJEFkQaBDEGiAJAFoY9rjTFvN3AAAAAElFTkSuQmCC","width":150,"height":150,"src":"/static/0cded3a3276425911d55a2552bf361bf/4148e/javascript.png","srcSet":"/static/0cded3a3276425911d55a2552bf361bf/4148e/javascript.png 1x,\n/static/0cded3a3276425911d55a2552bf361bf/de03e/javascript.png 1.5x,\n/static/0cded3a3276425911d55a2552bf361bf/1e9e2/javascript.png 2x"}}},"slug":"microtask-queue","date":"2020-04-04T00:00:00.000Z","categories":["Code"],"tags":["javascript.info","asynchronous"],"template":"post"},"fields":{"slug":"/microtask-queue/","date":"2020-04-04T00:00:00.000Z"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/microtask-queue/"}}}